==============================================================================
INSTALLATION                                          *splitjoin-installation*

There are several ways to install the plugin. The recommended one is by using
Tim Pope's pathogen (http://www.vim.org/scripts/script.php?script_id=2332). In
that case, you can clone the plugin's git repository like so:
>
    git clone git://github.com/AndrewRadev/splitjoin.vim.git ~/.vim/bundle/splitjoin
<
If your vim configuration is under git version control, you could also set up
the repository as a submodule, which would allow you to update more easily.
The command is (provided you're in ~/.vim):
>
    git submodule add git://github.com/AndrewRadev/splitjoin.vim.git bundle/splitjoin
<

Another way is to simply copy all the directories inside the ~.vim/ directory
(plugin, autoload, etc.)

TODO: install from zip file
TODO: install from vimball

After the plugin is installed, the command |SplitjoinSplit| will perform
splitting and |SplitjoinJoin| -- joining of the code under the cursor. It's
highly recommended to map these to keybindings, since the idea of the plugin
is to simplify these manipulations. An example keybinding that needs to go in
.vimrc:
>
    nmap <Leader>j :SplitjoinJoin<cr>
    nmap <Leader>s :SplitjoinSplit<cr>
<
With these mappings, and if the <Leader> is set to, for example, "_", then
"_j" would attempt to perform a join on the text block under the cursor and
"_s" would perform a split on the line.

My personal preference is to avoid mnemonics in this case and go for an
approach that makes more sense to my fingers instead:
>
    nmap sj :SplitjoinSplit<cr>
    nmap sk :SplitjoinJoin<cr>
<
Note that I'm using "sj" for splitting, not joining. To me, "splitting" a line
results in expanding it downwards, so using "j" seems more intuitive, likewise
for "k". Also note that the "s" key is generally taken (try :help s), but I
don't use it, so I've mapped it to <Nop>.

==============================================================================
RUBY                                                          *splitjoin-ruby*

If/unless clauses ~
>
    return "the answer" if 6 * 9 == 42

    if 6 * 9 == 42
      return "the answer"
    end
<

Hashes ~
>
    foo = { :bar => 'baz', :one => 'two' }

    foo = {
      :bar => 'baz',
      :one => 'two'
    }
<

Blocks ~
>
    Bar.new { |b| puts b.to_s }

    Bar.new do |b|
      puts b.to_s
    end
<

==============================================================================
HTML                                                          *splitjoin-html*

TODO

==============================================================================
ERUBY                                                        *splitjoin-eruby*

TODO


==============================================================================
TODO: yaml, python, javascript?



==============================================================================
INTERNALS                                                *splitjoin-internals*

  The only interface of the plugin is in 'plugin/splitjoin.vim'. It's a fairly
  short file containing two commands, |SplitjoinSplit| and |SplitjoinJoin|.
  All of the actual splitting and joining logic is in autoloaded files. The
  only things that these two commands do are:

    - Check the |b:splitjoin_join_callbacks| and |b:splitjoin_split_callbacks|
      respectively for a list of function names.
    - Invoke the functions, in order. If any of the functions returns a number
      different than 0, stop.

  The actual functions may do whatever they want, but it makes sense for them
  to return 0 only if they haven't made any modifications.

  The function names could be buffer-local, global, autoloaded, anything the
  |function()| call can use.

  Obviously, extending the plugin is straightforward -- it's enough to define
  a function for splitting and one for joining and add those to the buffer
  variable. Of course, that doesn't imply it's easy -- the functions would
  need to actually perform all the necessary manipulations and simply inform
  the plugin if they've been successful by returning a number other than 0 as
  a result.

  The file 'autoload/sj.vim' contains helpers that might be useful for said
  manipulations. There are functions for replacing bodies of text defined by
  normal mode motions or by line ranges, for saving and restoring the cursor
  position and possibly other interesting functions that might assist. They
  should be commented reasonably well.

  The other files in 'autoload/sj' might be useful as well, although they're
  mostly filetype-specific.

==============================================================================

vim:tw=78:sw=4:ft=help:norl:
